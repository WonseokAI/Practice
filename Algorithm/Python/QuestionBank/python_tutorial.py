# python 기본 문법 정리

'''

파이썬의 자료형은 기본 자료형을 제공할 뿐만 아니라, 사전 자료형, 집합 자료형 등 강력한 기능을 제공하는 자료형을 기본으로 내장하고 있다.

> 수 자료형

1. 정수형 : 양의 정수, 음의 정수, 0이 있다.
2. 실수형 : 소수점 아래의 데이터를 포함하는 수의 자료형. 소수부가 0이거나, 정수부가 0인 소수는 0을 생략할 수 있다.
           실수형 데이터를 표현하는 방식으로 파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다.
           e 다음에 오는 수는 10의 지수부를 의미한다. 예를 들어, 1e6 이라고 입력하게 되면, 10의 6제곱이 된다.
'''

# 정수형
# 양의 정수
a = 100
print(a)

# 음의 정수
a = -5
print(a)

# 0
a = 0
print(a)

# 실수형
# 양의 실수
a = 154.93
print(a)

# 음의 실수
a = -137.2
print(a)

# 소수부 생략
a = 5.
print(a)

# 정수부 생략
a = -.7
print(a)

# 10억의 지수 표현
a = 1e9
print(a)

# 657.5
a = 65.75e1
print(a)

# 3.954
a = 3954e-3
print(a)

'''
컴퓨터 시스템이 수를 처리할 때 2진수를 활용한다.
그리고 실수를 처리할 때 부동 소수점 방식을 사용한다.
이때 고정된 크기의 메모리를 할당하여 수를 저장하므로, 실수 정보를 표현하는 정확도에 한계를 가진다.
최대한 가깝게 표현하지만 표현된 값이 정확하지 않을 수 있다.
'''

a = 0.3 + 0.6
print(a)

if a == 0.9:
    print(True)
else:
    print(False)

'''
따라서 소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못해서 원하는 결과를 얻지 못할 수 있다.

이때 사용할 수 있는 함수가 round()이다.

round(a, b) : a는 반올림할 값이고 b는 소수점 몇 번째 자리까지 나타낼 것인가를 의미한다.
'''

a = 0.3 + 0.6
print(a, 4)

if round(a, 4) == 0.9:
    print(True)
else:
    print(False)

'''
숫자 자료형의 연산

프로그래밍을 하다보면 사칙연산(+,-,x,/)을 이용하여 계산한다.
이 중에 나누기 연산자(/)를 주의해서 사용해야 한다. 왜냐하면 나누기 연산자는 나눠진 결과를 기본적으로 실수형으로 처리하기 때문이다.
'''

a = 7
b = 3

# 나누기
print(a / b)

# 나머지
print(a % b)

# 몫
print(a // b)

# 거듭제곱
print(a ** b)


'''
리스트 자료형

리스트는 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용된다.

파이썬의 리스트 자료형은 다른 프로그래밍 언어에서의 배열 기능을 포함하고 있으며, 내부적으로 연결 리스트 자료구조를 채택하고 하므로

append(), remove() 등의 메서드를 지원한다.

'''

# 리스트 초기화 방법
a = [1,2,3,4,5,6,7,8,9]
print(a)

# 인덱스 n : (n - 1) 번째 원소에 접근
print(a[3])

# 빈 리스트 선언 방법 1
a = list()
print(a)

# 빈 리스트 선언 방법 2
a = []
print(a)

# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)

'''
리스트의 인덱싱과 슬라이싱

인덱스값을 입력하여 리스트의 특정한 원소에 접근하는 것을 '인덱싱'이라고 한다.

파이썬의 인덱스값은 양의 정수와 음의 정수를 모두 사용할 수 있으며, 음의 정수를 넣으면 원소를 거꾸로 탐색한다.

ex) 인덱스 -1은 가장 마지막 원소를 의미한다.

이러한 성질을 이용하여 인덱싱을 하면 특정 원소에 쉽게 접근하고 변경할 수 있다.

또한 리스트에서 연속적인 위치를 가지는 원소들을 가져와야 할 때는 '슬라이싱'을 사용할 수 있다.

슬라이싱을 사용할 때는 콜론(:)과 시작 인덱스와 마지막 인덱스를 이용하여 범위를 지정할 수 있다.
'''

a = [1,2,3,4,5,6,7,8,9]

# 뒤에서 첫 번째 원소 출력
print(a[-1])

# 뒤에서 세 번째 원소 출력
print(a[-3])

# 네 번째 원소 값 변경
a[3] = 7
print(a)

# 슬라이싱
print(a[1:7]) # 첫번째 원소와 마지막 원소를 뺀 나머지

'''
리스트 컴프리헨션

리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.

대괄호([])안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있다.

한 줄로 간결하고 강력한 코드를 만들 수 있다.
'''
# 0부터 100까지 홀수만 포함하는 리스트
array = [i for i in range(100) if i % 2 == 1]
print(array)

# 0부터 5까지 제곱수를 포함하는 리스트
array = [i * i for i in range(1, 10)]
print(array)

# N X M 2차원 리스트 초기화
n = 7
m = 4
array = [[0] * m for _ in range(n)]     # 언더바(_)는 반복을 위한 변수의 값을 무시하고자 할 때 사용한다.
print(array)

# 2차원 리스트는 반드시 리스트 컴프리헨션을 사용하자.
# 내부적으로 포함된 리스트들이 모두 동일한 객체에 대한 n개의 레퍼런스로 인식되기 때문이다.

'''
리스트 관련 메서드

1. append() : 변수명.append() : 리스트에 원소를 하나 삽입할 때 사용한다. : O(1)
2. sort() : 변수명.sort()는 오름차순, 변수명.sort(reverse = True)는 내림차순 : O(NlogN)
3. reverse() : 변수명.reverse() : 리스트의 원소의 순서를 모두 뒤집어 놓는다 : O(N)
4. insert() : insert(삽입할 위치 인덱스, 삽입할 값) : 특정한 인덱스 위치에 원소를 삽입할 때 사용한다 : O(N)
5. count() : 변수명.count(특정 값) : 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다 : O(N)
6. remove() : 변수명.remove(특정 값) : 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다 : O(N)
'''

a = [1, 4, 5]
print("Original list: ", a)

# 리스트에 원소 삽입
a.append(2)
print("삽입: ", a)

# 오름차순 정렬
a.sort()
print("오름차순 정렬: ", a)

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬: ", a)

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기: ", a)

# 특정 인덱스에 데이터 추가
a.insert(2,3)
print("인덱스 2에 3 추가: ", a)

# 특정 값인 데이터 개수 세기
print("값이 3인 데이터 개수: ", a.count(3))

# 특정 값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a)

'''
insert()와 append()에 대해서 조금 더 생각을 해보자면,

insert()의 시간 복잡도는 O(N)이다. 왜냐하면 중간 위치에 삽입할 경우 리스으틔 원소 위치를 조정해줘야 하기 때문이다.

그에 반해, append() 시간 복잡도는 O(1)이다. 따라서 이 둘을 적절히 사용해야 한다.

insert()를 남발하면 시간 제한을 못 지킬수도 있다.

remove()의 시간 복잡도 또한 O(N)이다. 왜냐하면 중간 위치에 삭제할 경우 리스으틔 원소 위치를 조정해줘야 하기 때문이다.
'''


'''
특정한 값의 원소를 모두 제거하는 방법

이러한 함수는 따로 없지만, 리스트 컴프리헨션으로 쉽게 구현할 수 있다.
'''

a = [1,2,3,4,5,5,5]
remove_set = [3,5]

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)


# 문자열 자료형

'''
문자열 초기화

문자열 변수를 초기화할 때, 큰따옴표(")나 작은따옴표(')를 이용한다.

가끔씩 문자열 안에 큰따옴표나 작은 따옴표가 포함되어야 할 경우가 있다. 

1. 큰따옴표로 문자열을 감싸는 경우, 문자열안에서 작은 따옴표 사용가능
2. 작은따옴표로 문자열을 감싸는 경우, 문자열안에서 큰 따옴표 사용가능
3. 위의 경우가 아닌, 따옴표를 더 사용하는 경우 백슬래시(\)를 사용해서 문자열에 원하는 만큼 따옴표를 추가 시킬 수 있다.
'''

data = "Hello World"
print(data)

data = "Don't you know \"Python\"? "
print(data)

'''
문자열 연산

파이썬은 문자열에 대한 연산도 지원한다.

문자열 변수끼리 더하면 연결되고, 곱하면 복제가된다.

문자열 데이터는 'char 배열' 이기때문에 인덱싱과 슬라이싱을 할 수 있다.
'''
# 문자열 덧셈
a = "Hello"
b = "World"
print(a + " " + b)

# 문자열 곱셈
a = "String"
print(a * 3)


'''
튜플 자료형

- 튜플은 한 번 선언하면 값을 변경할 수 없다.
- 리스트는 소괄호를 이용한다.

- 튜플을 이용하게 되면 혹여나 자신이 알고리즘을 잘못 작성함으로써 변경하면 안되는 값이 변경되는지 여부를 체크할 수 있다.
- 튜플은 리스트에 비해 상대적으로 공간 효율적이고, 각 원소들의 성질이 다를 때 주로 사용된다.
'''

a = (1, 2, 3, 4)
print(a)

'''
사전 자료형

- 사전 자료형은 key와 value의 쌍을 데이터로 가지는 자료형이다.
- 리스트나 튜플은 값을 순차적으로 저장하지만, 사전 자료형은 순서가 없고, 변경 불가능한 데이터를 key로 사용할 수 있다.
- 파이썬의 사전 자료형은 내부적으로 Hash Table을 이용하므로, 데이터의 검색 및 수정을 O(1)의 시간에 처리할 수 있다.

- 사전 자료형에 특정한 원소가 있는지 검사할 때 'in'을 사용할 수 있다.(리스트나 튜플에서도 사용 가능)
'''
data = dict()
data['one'] = 1
data['two'] = 2
data['three'] = 3
print(data)

if 'two' in data:
    print('exist!')

# key 데이터만 담은 리스트
key_list = data.keys()

# value 데이터만 담은 리스트
value_list = data.values()

print(key_list)
print(value_list)

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
    print(data[key])


'''
집합 자료형

- Set을 처리하기 위한 자료형, 기본적으로 리스트 혹은 문자열을 이용해서 만들 수 있다.
- 중복을 허용하지 않고, 순서가 없다.
- 인덱싱으로 값을 얻을 수 없다.
- 키가 존재하지 않고, value만 저장한다.
- 특정 원소가 존재하는지 검사하는 연산의 시간 복잡도는 O(1)이다.
- 특정 데이터가 이미 등장한 적이 있는지 여부를 체크할 때 매우 효과적이다.

- 집합 연산으로 합집합, 교집합, 차집합 연산을 지원한다.

- 하나의 값을 추가할 때 add() : O(1)
- 여러 개의 값을 한꺼번에 추가할 때 update()
- 특정한 값을 제거할 때 remove() : O(1)
'''

# 집합 자료형 초기화 방법 1
data = set([1, 1, 2, 3, 4, 4, 5])
print(data)

# 집합 자료형 초기화 방법 2
data = {1, 1, 2, 3, 4, 4, 5}
print(data)

a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

# 합집합
print(a | b)

# 교집합
print(a & b)

# 차집합
print(a - b)

data = set([1,2,3])
print(data)

# 새로운 원소 추가
data.add(4)
print(data)

# 새로운 원소 여러 개 추가
data.update([5,6])
print(data)

# 특정한 값을 갖는 원소 삭제
data.remove(3)
print(data)


'''
조건문

- 프로그램의 흐름을 제어하는 문법
- 조건문을 이용해서 프로그램의 로직을 설정한다.

- 들여쓰기로 블록을 설정한다.
'''

score = 89

if score >= 90:
    print("A")
elif score >= 80:
    print("B")
elif score >= 70:
    print("C")
else:
    print("F")


'''
- 비교 연산자 : ==, !=, >, <, >=, <=

- 논리 연산자 : and, or, not

- in 연산자, not in 연산자 : 여러 개의 데이터를 담는 자료형에서 자료형 안에 어떤 값이 존재하는지 확인하는데 사용한다.

- pass를 사용하면 해당 부분을 그냥 넘어간다. 나중에 코드를 완성하고 싶을 때 주로 사용한다.
'''

score = 100

if score == 100:
    pass
else:
    print("study study study study")


# 조건문에서 실행될 소스코드가 한 줄인 경우, 줄 바꿈을 하지 않아도 간략하게 표현할 수 있다.
score = 99

if score == 100: result = "Success"
else: result = "Fail"

# 조건부 표현식
score = 100
result = "Success" if score == 100 else "Fail"

print(result)

# 조건부 표현식으로 필터를 만들 수 있다.
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = [3, 5]

result = [i for i in a if i not in remove_set]
print(result)


'''
반복문

- 특정한 소스코드를 반복적으로 실행할 때 사용한다.
- while문, for문
'''



